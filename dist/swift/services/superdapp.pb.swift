// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/superdapp.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Superdapp_ErcType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case erc20 // = 0
  case erc721 // = 1
  case erc1155 // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .erc20
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .erc20
    case 1: self = .erc721
    case 2: self = .erc1155
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .erc20: return 0
    case .erc721: return 1
    case .erc1155: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Superdapp_ErcType] = [
    .erc20,
    .erc721,
    .erc1155,
  ]

}

enum Superdapp_Actions: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case send // = 0
  case receive // = 1
  case mint // = 2
  case burn // = 3
  case vote // = 4
  case delegate // = 5
  case collect // = 6
  case approve // = 7
  case revoke // = 8
  case swap // = 9
  case borrow // = 10
  case repay // = 11
  case depositLoan // = 12
  case withdrawLoan // = 13
  case depositLiquidity // = 14
  case withdrawLiquidity // = 15
  case depositFarm // = 16
  case withdrawFarm // = 17
  case UNRECOGNIZED(Int)

  init() {
    self = .send
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .send
    case 1: self = .receive
    case 2: self = .mint
    case 3: self = .burn
    case 4: self = .vote
    case 5: self = .delegate
    case 6: self = .collect
    case 7: self = .approve
    case 8: self = .revoke
    case 9: self = .swap
    case 10: self = .borrow
    case 11: self = .repay
    case 12: self = .depositLoan
    case 13: self = .withdrawLoan
    case 14: self = .depositLiquidity
    case 15: self = .withdrawLiquidity
    case 16: self = .depositFarm
    case 17: self = .withdrawFarm
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .send: return 0
    case .receive: return 1
    case .mint: return 2
    case .burn: return 3
    case .vote: return 4
    case .delegate: return 5
    case .collect: return 6
    case .approve: return 7
    case .revoke: return 8
    case .swap: return 9
    case .borrow: return 10
    case .repay: return 11
    case .depositLoan: return 12
    case .withdrawLoan: return 13
    case .depositLiquidity: return 14
    case .withdrawLiquidity: return 15
    case .depositFarm: return 16
    case .withdrawFarm: return 17
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Superdapp_Actions] = [
    .send,
    .receive,
    .mint,
    .burn,
    .vote,
    .delegate,
    .collect,
    .approve,
    .revoke,
    .swap,
    .borrow,
    .repay,
    .depositLoan,
    .withdrawLoan,
    .depositLiquidity,
    .withdrawLiquidity,
    .depositFarm,
    .withdrawFarm,
  ]

}

struct Superdapp_GetTokenBundlesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var evmPublicKeys: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Superdapp_TokenBundleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tokenBundles: [Superdapp_TokenBundle] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Superdapp_Token: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var erc: Superdapp_ErcType = .erc20

  var address: String = String()

  var chainID: Int32 = 0

  var name: String = String()

  var symbol: String = String()

  var decimals: Int32 = 0

  var actions: [Superdapp_Actions] = []

  var balance: Superdapp_Balance {
    get {return _balance ?? Superdapp_Balance()}
    set {_balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  var hasBalance: Bool {return self._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  mutating func clearBalance() {self._balance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _balance: Superdapp_Balance? = nil
}

struct Superdapp_Balance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var value: Double = 0

  var fiat: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Superdapp_TokenBundle: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  var `in`: [Superdapp_Token] = []

  var out: [Superdapp_Token] = []

  var actions: [Superdapp_Actions] = []

  var balance: Superdapp_Balance {
    get {return _balance ?? Superdapp_Balance()}
    set {_balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  var hasBalance: Bool {return self._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  mutating func clearBalance() {self._balance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _title: String? = nil
  fileprivate var _balance: Superdapp_Balance? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "superdapp"

extension Superdapp_ErcType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERC_20"),
    1: .same(proto: "ERC_721"),
    2: .same(proto: "ERC_1155"),
  ]
}

extension Superdapp_Actions: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SEND"),
    1: .same(proto: "RECEIVE"),
    2: .same(proto: "MINT"),
    3: .same(proto: "BURN"),
    4: .same(proto: "VOTE"),
    5: .same(proto: "DELEGATE"),
    6: .same(proto: "COLLECT"),
    7: .same(proto: "APPROVE"),
    8: .same(proto: "REVOKE"),
    9: .same(proto: "SWAP"),
    10: .same(proto: "BORROW"),
    11: .same(proto: "REPAY"),
    12: .same(proto: "DEPOSIT_LOAN"),
    13: .same(proto: "WITHDRAW_LOAN"),
    14: .same(proto: "DEPOSIT_LIQUIDITY"),
    15: .same(proto: "WITHDRAW_LIQUIDITY"),
    16: .same(proto: "DEPOSIT_FARM"),
    17: .same(proto: "WITHDRAW_FARM"),
  ]
}

extension Superdapp_GetTokenBundlesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTokenBundlesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "evm_public_keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.evmPublicKeys) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.evmPublicKeys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.evmPublicKeys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Superdapp_GetTokenBundlesRequest, rhs: Superdapp_GetTokenBundlesRequest) -> Bool {
    if lhs.evmPublicKeys != rhs.evmPublicKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Superdapp_TokenBundleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenBundleResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_bundles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tokenBundles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenBundles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokenBundles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Superdapp_TokenBundleResponse, rhs: Superdapp_TokenBundleResponse) -> Bool {
    if lhs.tokenBundles != rhs.tokenBundles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Superdapp_Token: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Token"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "erc"),
    3: .same(proto: "address"),
    4: .standard(proto: "chain_id"),
    5: .same(proto: "name"),
    6: .same(proto: "symbol"),
    7: .same(proto: "decimals"),
    8: .same(proto: "actions"),
    9: .same(proto: "balance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.erc) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.chainID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.decimals) }()
      case 8: try { try decoder.decodeRepeatedEnumField(value: &self.actions) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._balance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.erc != .erc20 {
      try visitor.visitSingularEnumField(value: self.erc, fieldNumber: 2)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 3)
    }
    if self.chainID != 0 {
      try visitor.visitSingularInt32Field(value: self.chainID, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 6)
    }
    if self.decimals != 0 {
      try visitor.visitSingularInt32Field(value: self.decimals, fieldNumber: 7)
    }
    if !self.actions.isEmpty {
      try visitor.visitPackedEnumField(value: self.actions, fieldNumber: 8)
    }
    try { if let v = self._balance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Superdapp_Token, rhs: Superdapp_Token) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.erc != rhs.erc {return false}
    if lhs.address != rhs.address {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.decimals != rhs.decimals {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs._balance != rhs._balance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Superdapp_Balance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Balance"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "value"),
    3: .same(proto: "fiat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.fiat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.value.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 2)
    }
    if self.fiat.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.fiat, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Superdapp_Balance, rhs: Superdapp_Balance) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.value != rhs.value {return false}
    if lhs.fiat != rhs.fiat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Superdapp_TokenBundle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenBundle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .same(proto: "in"),
    4: .same(proto: "out"),
    5: .same(proto: "actions"),
    6: .same(proto: "balance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.`in`) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.out) }()
      case 5: try { try decoder.decodeRepeatedEnumField(value: &self.actions) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._balance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.`in`.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.`in`, fieldNumber: 3)
    }
    if !self.out.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.out, fieldNumber: 4)
    }
    if !self.actions.isEmpty {
      try visitor.visitPackedEnumField(value: self.actions, fieldNumber: 5)
    }
    try { if let v = self._balance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Superdapp_TokenBundle, rhs: Superdapp_TokenBundle) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._title != rhs._title {return false}
    if lhs.`in` != rhs.`in` {return false}
    if lhs.out != rhs.out {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs._balance != rhs._balance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
